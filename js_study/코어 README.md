# CHAPTER 1 데이터 타입

## 01 데이터 타입의 종류

- primitive type (기본형) : 불변성을 띔
  - Number
  - String
  - Boolean
  - null
  - undefined
  - symbol
- Reference type
  - Array
  - Function
  - Date
  - RegExp
  - Map, WeakMap
  - Set, WeakSet

## 02 데이터 타입에 관한 배경지식

### 02-01 메모리와 데이터

- 비트 : 0 또는 1만 표현할 수 있는 하나의 메모리 조각
- 메모리는 매우 많은 비트로 구성 -> 각 비트는 고유한 식별자를 통해 위치를 확인 가능
- 비트를 한 단위로 묶으면 낭비되는 비트가 생김 -> 적정한 공간을 묶는 것이 편리 -> 바이트 단위의 생성
- 1바이트 = 8비트
- 1비트 마다 0 또는 1의 두 가지 값을 표현할 수 있으므로 1바이트는 총 256개의 값을 표현 가능
- 모든 데이터는 바이트 단위의 식별, 즉 메모리 주솟값을 통해 서로 구분하고 연결 가능

### 02-02 식별자와 변수

- 변수 : 변할 수 있는 수(데이터)
- 식별자 : 어떤 데이터를 식별하는 데 사용하는 이름 (변수명)

## 03 변수 선언과 데이터 할당

### 03-01 변수 선언

- 변수 : 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇
- `var a;`와 같은 명령을 받은 컴퓨터는 메모리에서 비어있는 공간 확보 -> 공간의 이름(식별자)를 `a`라고 지정 : 변수 선언 과정

### 03-02 데이터 할당

```
var a; // 변수 a 선언
a = "abc"; // 변수 a에 데이터 할당

var a = "abc"; // 변수 선언과 할당을 한 문장으로 표현
```

- 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열을 저장하고, 그 주소를 변수 영역에 저장
- 데이터의 성질에 따라 메모리 영역은 '변수 영역'과 '데이터 영역'으로 나뉨
- 데이터 할당에 대한 메모리 영역의 변화
  - 변수 영역에서 빈 공간 확보
  - 확보한 공간의 식별자 지정
  - 데이터 영역의 빈 공간에 문자열 저장
  - 변수 영역에서 식별자 검색
  - 앞서 저장한 문자열의 주소를 변수 영역에 대입
- 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 효율적으로 관리하기 위함

## 04 기본형 데이터와 참조형 데이터

### 04-01 불변값

- 변수와 상수를 구분 : '변수 영역 메모리'의 변경 가능성
  - 변수 : 바꿀 수 있는 것
  - 상수 : 바꿀 수 없는 것
- 불변성 여부를 구분 : '데이터 영역 메모리'의 변경 가능성
  - 기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값

```
var a = "abc";
a = a + "def"; // "abcdef"를 만들어 그 주소를 변수 a에 저장

var b = 5; // 데이터 영역에서 5를 찾고 없으면 데이터 공간 하나 생성
var c = 5; // 데이터 영역에서 5가 있기에 주소 재활용
b = 7; // 기존 7을 찾아서 있으면 재활용, 없으면 새로 만들어 b에 저장
```

### 04-02 가변성

- 참조형 데이터를 변수에 할당하는 과정

+++++++++++++

# CHAPTER 4 콜백 함수

## 01 콜백 함수

- 콜백 함수 : 다른 코드의 인자로 넘겨주는 함수
- 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행 (제어권 위임)

## 02 제어권

## 02-01 호출 시점

```
var count = 0;
var timer = setInterval(function () {
  console.log(count);
  if (++count > 4) clearInterval(timer);
}, 300);
```

- setInteval의 구조 : `var intervalID = scope.setInteval(func, delay[, param1, param2, ...]);`
  - scope에는 Window 객체 또는 Worker의 인스턴스가 들어올 수 있음
  - 매개변수로 func, delay 값은 반드시 전달 (나머지는 선택적)
    - func : 함수
    - delay는 밀리초 단위의 숫자
    - func에 넘겨준 함수는 매 delay마다 실행되며, 그 결과 어떠한 값도 리턴하지 않음
  - setInteval를 실행하면 반복적으로 실행되는 내용 자체를 특정할 수 있는 고유한 ID 값이 반환 -> 중간에 종료하기 위함

```
var count = 0;
var cbFunc = function () {
  console.log(count);
  if (++count > 4) clearInterval(timer);
};
var timer = setInterval(cbFunc, 300);

// 실행 결과
// 0 (0.3초)
// 1 (0.6초)
// 2 (0.9초)
// 3 (1.2초)
// 4 (1.5초)
```

- SetInteval에 전달한 첫 번째 인자인 cbFunc 함수가 콜백 함수

| code                     | 호출 주체  | 제어권     |
| ------------------------ | ---------- | ---------- |
| cbFunc();                | 사용자     | 사용자     |
| setInteval(cbFunc, 300); | setInteval | setInteval |

- 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시점에 대한 제어권을 가짐

### 02-02 인자

```
var newArr = [10, 20, 30].map(function (currentValue, index) {
  console.log(currentValue, index);
  return currentValue + 5;
});

console.log(newArr);

// 실행 결과
// 10 0
// 20 1
// 30 2
// [15, 25, 35]
```

- Array의 prototype에 담긴 map 메서드의 구조
  - 첫 번째 인자 : callback 함수
    - 콜백 함수의 첫 번째 인자 : 배열의 요소 중 현재 값
    - 콜백 함수의 두 번째 인자 : 현재 값의 인덱스
    - 콜백 함수의 세 번째 인자 : map 메서드의 대상이 되는 배열
  - 생략 가능한 두 번째 인자 : 콜백 함수 내부에서 this로 인식할 대상 (생략 되면 전역객체가 바인딩)
  - 메서드 대상이 되는 배열의 모든 요소들을 처음부터 끝까지 하나씩 꺼내어 콜백 함수를 반복 호출하고, 콜백 함수의 실행 결과들을 모아 새로운 배열 생성

```
Array.prototype.map(callback[, thisArg])
callback: function(currentValue, index, array);
```

- 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가짐

## 02-03 this

- 콜백 함수도 함수이기 때문에 기본적으로는 this가 전역객체를 참조하지만, 제어권을 넘겨받을 코드에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 됨
